vue中等题

10.vue2.0响应式数据的原理

```
//响应式：一个网站可以兼容多个终端
整体思路是数据劫持+观察者模式
对象内部用defineReactive方法，使用Object.defineProperty将属性进行劫持
数组通过重写的方法实现
当页面使用对应属性，每个属性都有自己的dep属性，存放它所依赖的watcher，当属性变化之后会通知自己的watcher去更新
```

11.vue如何检测数组变化

```
考虑到性能，没有用defineProperty对数组的每一项进行拦截，而是选择7种数组方法重写（push，shift，pop，slice，UNshift，sort，reverse）
所以在vue中，修改数组的索引和长度是无法监控的
```

12.vue3.0使用过吗？了解多少

```
1.响应式原理的改变，vue3用proxy来取代vue2的Object.defineProperty。proxy可以直接监听对象和数组的变化，并且有多达13中拦截方法
2.组件声明方式：vue3新增了一个composition api setup 选项
3.slot插槽语法变化，v-model升级
 
```

13.2 和 3 响应式原理的区别

```
proxy可以直接监听对象和数组的变化，并且有多达13中拦截方法
```

14.父子组件的生命周期顺序

```
父
```

15.虚拟dom是什么，有什么有点

```
在浏览器中操作dom是很昂贵的，频繁操作会产生一些性能问题，所以虚拟dom产生了。vue2的虚拟dom本质是用一个原生的js对象描述一个dom节点，对真实dom的抽象
优点：
缺点：不能达到优化的极限，第一次渲染时由于多了一层虚拟dom会比较慢
```

16.v-model原理

```
v-model只是语法糖（相当于成语，只是更方便形象，实际上对语言没有影响）在内部为不同的输入元素使用不同的property并抛出不同的事件
1.text和textarea中使用value property属性和input事件
2.checkbox和radio中使用checkedproperty 和change事件
3.select字段将value作为prop并将change作为事件
```

17.v-for为什么要加key

```
如果不用key，那么vue就会用一种最大限度减少动态元素并且尽可能的方式修改复用相同类型元素的算法。通过key，我们的操作可以更准确（非就地复用，在sameNode函数中对比就可以避免）更快速（利用key生成唯一的map对象获取对应节点，比遍历更快）
```

18.vue事件绑定原理

```
原生js：用addEventListener绑定给真实元素
vue：on和emit是基于发布订阅模式的，维护一个事件中心，on的时候将事件按名称存在事件中心，叫订阅者，然后emit将对应事件发布，去执行对应事件中心里对应的监听器
```

19 vue-router路由钩子函数和执行顺序

```
钩子函数种类有路由守卫，全局守卫和组件守卫
。。。
```

20.vue-router动态路由是什么，有什么问题

```
我们通常需要把某种模式匹配到所有的路由，全部映射到同个组件。比如说，我们有一个user组件，对于所有id不同的用户，都要用这个组件进行渲染，那么可以在vue-router的路由路径中使用"动态路径参数" dynamic segment 来达到这个效果
```

ps如果vue-router组件复用导致路由参数失效怎么办？

```
watch监听路由参数再发请求和：key来阻止复用
```



21.对vuex的理解

```
专门针对vue提供的全局状态管理系统，用于多个组件中数据共享，数据缓存等，但是无法持久化
```

22.vuex页面刷新数据丢失怎么解决

```
需要做vuex数据持久化，一般用本地存储的方案来保存数据 第三方插件：vuex-persist
```

23.vuex为什么要分模块并且加命名空间

```
模块：使用单一状态数，应用一变复杂，store对象有可能变得相当臃肿，所以可以把store分隔成模块（module）拥有自己的state，mutation，action，getter甚至是嵌套子模块
命名空间：如果希望模块具有更高的封装度和复用性，可以使其成为自带命名空间的模块
```

24.vue ssr

```
ssr也就是服务端渲染，也就是将vue在客户端把标签渲染成HTML的工作在服务端完成，再把HTML直接返回客户端
优点：ssr有更好的SEO，并且首屏加载速度快
缺点：开发条件受到限制，服务端渲染只支持beforeCreate 和 created两个钩子，服务端会有更大的负载需求
```

25.vue的设计模式

```

```

26.vue性能优化

```
v-if和v-on区分使用场景
computed和watch区分使用场景
v-for要加key并且避免和v-if一起用
防止内存，组件销毁后把全局变量和实践销毁
防抖节流（函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。）
服务端渲染ssr 或者 预渲染
第三方插件按需引入
```

